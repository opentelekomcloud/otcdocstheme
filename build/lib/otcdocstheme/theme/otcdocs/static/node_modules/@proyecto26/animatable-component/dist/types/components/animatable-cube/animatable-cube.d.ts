import { EventEmitter } from '../../stencil-public-runtime';
import { IAnimatableComponent } from '../../models/animatable';
import { AnimationsType } from '../../animations';
/**
 * animatable-cube
 *
 * @slot - Content is placed into the cube.
 * @slot front-face - Content is placed into the front face of the cube.
 * @slot back-face - Content is placed into the back face of the cube.
 * @slot right-face - Content is placed into the right face of the cube.
 * @slot left-face - Content is placed into the left face of the cube.
 * @slot top-face - Content is placed into the top face of the cube.
 * @slot bottom-face - Content is placed into the bottom face of the cube.
 */
export declare class Cube implements IAnimatableComponent {
  /**
   * Animation manager for Animatable
   */
  private manager?;
  el: HTMLElement;
  get element(): HTMLElement;
  /**
   * Name of the animation to get the keyFrames
   */
  animation?: AnimationsType;
  animationDidChangeHandler(animation: AnimationsType): void;
  /**
   * Keyframes of the animation.
   */
  keyFrames?: Keyframe[];
  /**
   * Keyframes of the animation in string format.
   */
  keyFramesData?: string;
  /**
   * Get keyFrames of the animation from string data.
   * @param text - The string with the keyFrames of the animation.
   */
  keyFramesDidChangeHandler(text: string): void;
  /**
   * Default options of the animation.
   */
  options?: KeyframeAnimationOptions;
  /**
   * Get options of the animation from string data.
   * @param text - The string with the options of the animation.
   */
  optionsDidChangeHandler(options: KeyframeAnimationOptions): void;
  /**
   * Default options of the animation in string format.
   */
  optionsData?: string;
  /**
   * Get options of the animation from string data.
   * @param text - The string with the options of the animation.
   */
  optionsDataDidChangeHandler(text: string): void;
  /**
   * A DOMString with which to reference the animation.
   */
  animateId?: string;
  /**
   * The number of milliseconds to delay the start of the animation.
   * Defaults to 0.
   */
  delay?: number;
  /**
   * The number of milliseconds to delay after the end of an animation.
   */
  endDelay?: number;
  /**
   * The number of milliseconds each iteration of the animation takes to complete.
   * Defaults to 0.
   */
  duration?: number;
  /**
   * Direction of the animation.
   */
  direction?: PlaybackDirection;
  /**
   * Determines how values are combined between this animation and other,
   * separate animations that do not specify their own specific composite operation.
   * Defaults to `replace`.
   */
  composite?: CompositeOperation;
  /**
   * The rate of the animation's change over time.
   */
  easing?: string;
  /**
   * Dictates whether the animation's effects should be reflected
   * by the element(s) prior to playing ("backwards"), retained after the animation
   * has completed playing ("forwards"), or both. Defaults to "none".
   */
  fill?: FillMode;
  /**
   * The number of times the animation should repeat.
   * Defaults to `1`, and can also take a value of `Infinity` to make it repeat for as long as the element exists.
   */
  iterations?: number;
  /**
   * Describes at what point in the iteration the animation should start.
   */
  iterationStart?: number;
  /**
   * Determines how values build from iteration to iteration in this animation.
   */
  iterationComposite?: IterationCompositeOperation;
  /**
   * Start the animation when the component is mounted.
   */
  autoPlay?: boolean;
  /**
   * The class name to be applied when the animation starts
   */
  fromClassName?: string;
  /**
   * The class name to be applied when the animation ends
   */
  toClassName?: string;
  /**
   * Sets the current time value of the animation in milliseconds, whether running or paused.
   */
  currentTime?: number;
  setCurrenTime(newValue: number): void;
  /**
   * Returns the current time value of the animation in milliseconds, whether running or paused.
   */
  getCurrentTime(): Promise<number>;
  /**
   * Sets the scheduled time when an animation's playback should begin.
   */
  startTime?: number;
  setStartTime(newValue: number): void;
  /**
   * Returns the scheduled time when an animation's playback should begin.
   */
  getStartTime(): Promise<number>;
  /**
   * Indicates whether the animation is currently waiting
   * for an asynchronous operation such as initiating playback
   * or pausing a running animation.
   */
  getPending(): Promise<boolean>;
  /**
   * Sets the playback rate of the animation.
   */
  playbackRate?: number;
  setPlaybackRate(newValue: number): void;
  /**
   * Returns the playback rate of the animation.
   */
  getPlaybackRate(): Promise<number>;
  /**
   * Returns an enumerated value describing the playback state of an animation.
   */
  getPlayState(): Promise<AnimationPlayState>;
  /**
   * This event is sent when the animation is going to play.
   */
  onStart: EventEmitter<HTMLElement>;
  /**
   * This event is sent when the animation finishes playing.
   */
  onFinish: EventEmitter<HTMLElement>;
  /**
   * This event is sent when the animation is cancelled.
   */
  onCancel: EventEmitter<HTMLElement>;
  /**
   * Clears all `KeyframeEffects` caused by this animation and aborts its playback.
   */
  cancel(): Promise<void>;
  /**
   * Sets the current playback time to the end of the animation
   * corresponding to the current playback direction.
   */
  finish(): Promise<void>;
  /**
   * Suspends playback of the animation.
   */
  pause(): Promise<void>;
  /**
   * Starts or resumes playing of an animation.
   */
  play(): Promise<void>;
  /**
   * Reverses the playback direction, meaning the animation ends at its beginning.
   */
  reverse(): Promise<void>;
  /**
   * Clear the current animation
   */
  clear(): Promise<void>;
  /**
   * Destroy the current animation
   */
  destroy(): Promise<void>;
  /**
   * Initialize manager
   */
  connectedCallback(): void;
  componentDidLoad(): void;
  componentShouldUpdate(): void;
  componentDidUpdate(): void;
  disconnectedCallback(): void;
  render(): any;
}
